<HTML>
<HEAD>
<meta charset="UTF-8">
<title>Selector.<init> - sok</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">sok</a>&nbsp;/&nbsp;<a href="../index.html">Sok.Selector</a>&nbsp;/&nbsp;<a href="index.html">Selector</a>&nbsp;/&nbsp;<a href="./-init-.html">&lt;init&gt;</a><br/>
<br/>
<h1>&lt;init&gt;</h1>
<a name="Sok.Selector.Selector$&lt;init&gt;()"></a>
<code><span class="identifier">Selector</span><span class="symbol">(</span><span class="symbol">)</span></code>
<p><strong>Platform and version requirements:</strong> JVM, Native</p>
<p>Class wrapping the NIO Selector class for a more "coroutine-friendly" approach. Each <code>SelectableCHannel</code> will have a <code>SuspentionMap</code> as
attachment, this map contains all teh Continuations/Lambda to resume/call when an event come in.</p>
<p>Sockets register quite frequently and as the NIO Selector class blocks any registration while selecting we have to implement a way to
synchronize registrations and the Selector class. This is done by sharing the <code>CoroutineScope</code> of the Selector to the <code>SuspentionMap</code>
classes, this way the <code>SuspentionMap</code> is able to launch coroutine on the Selector Thread, thus ensuring mutual-exclusion.</p>
<p>To reduce the number of registration, a socket may register for a unknown number of event. If so the selector will call a lambda after
each event and this lambda will return if the Selector should keep the registration or not. This method slow down the selector but
the performance gain is worth it.</p>
</BODY>
</HTML>
